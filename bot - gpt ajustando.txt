// src/bot.js (revisado)
import { getMemory, setMemory } from './memory.js';
import prompts from './prompts/base.js';              // adapter (default export)
import { productPrompt } from './prompts/product.js';
import { greet } from './flows/greet.js';
import { qualify } from './flows/qualify.js';
import { offer } from './flows/offer.js';
import { closeDeal } from './flows/close.js';

// ===== Configs =====
const PRICE_TARGET = Number(process.env.PRICE_TARGET || 170);

// JSON carregado pelo adapter (pode ser null se estiver em fallback JS)
const CFG = prompts.__carla_json || null;

// Atalhos tolerantes para dados do produto/regras
const PRODUCT = CFG?.product || {};
const PRICE = PRODUCT?.price || {};
const RULES  = CFG?.rules || {};
const MEDIA  = RULES?.media || null;

// ===== Helpers =====
function pick(arr = []) {
  return arr[Math.floor(Math.random() * arr.length)];
}

function textIndicaMidia(text = '') {
  // Heur√≠stica: usu√°rio dizendo que mandou m√≠dia
  const re = /(te?\s*(mandei|enviei)|segue|acabei de\s*(mandar|enviar)).*(foto|imagem|√°udio|audio|v√≠deo|video|documento|arquivo)/i;
  return re.test(text);
}

function respostaMidia() {
  // Variantes padr√£o para quando o usu√°rio manda m√≠dia (e a ‚Äúcentral n√£o abre‚Äù)
  const variantsFromRules =
    typeof MEDIA === 'string'
      ? [MEDIA] // caso seja string √∫nica em 000
      : (MEDIA?.variants || null);

  const variants = variantsFromRules || [
    'Amiga, minha central n√£o abre √°udio/foto üòÖ me conta rapidinho por texto? Assim j√° te ajudo agora!',
    'Consigo te ajudar mais r√°pido por texto üíï me resume aqui o que apareceu?'
  ];
  return pick(variants);
}

// Identifica inten√ß√µes objetivas no texto do cliente
function detectDirectIntent(text='') {
  const t = text.toLowerCase();
  if (/(quantos?\s*ml|ml|quantidade)/i.test(t)) return 'ml';
  if (/(sem\s*formol|formol)/i.test(t)) return 'formol';
  if (/(quanto\s*custa|pre√ßo|valor)/i.test(t)) return 'price';
  if (/(link|checkout|quero\s*comprar|onde\s*pago)/i.test(t)) return 'checkout';
  if (/(foto|imagem|mostra|manda a foto)/i.test(t)) return 'photo';
  return null;
}

// Garante apenas 1 pergunta por resposta (remove excessos)
function enforceSingleQuestion(answer='') {
  const parts = answer.split('?');
  if (parts.length <= 2) return answer;           // 0 ou 1 '?'
  return parts.slice(0,2).join('?').trim();       // mant√©m s√≥ a primeira pergunta
}

// Responde direto para intents objetivas, sem puxar assunto extra
function directAnswer(intent) {
  if (!intent) return null;

  const vol = PRODUCT?.volume_ml ? `${PRODUCT.volume_ml}ml` : '500ml';
  const dur = PRODUCT?.duration_hint || 'dura at√© 3 meses';
  const priceLabel = PRICE?.label || 'R$170 com frete gr√°tis';
  const checkoutUrl = PRICE?.checkout_url || 'https://entrega.logzz.com.br/pay/memmpxgmg/progcreme170';

  if (intent === 'ml')      return `${vol}, ${dur} üòâ`;
  if (intent === 'formol')  return 'Sim üåø f√≥rmula vegetal, sem formol.';
  if (intent === 'price')   return `Hoje est√° por ${priceLabel} ‚ú®`;
  if (intent === 'checkout')return `Perfeito üéâ aqui est√° o link oficial do checkout: ${checkoutUrl}`;
  if (intent === 'photo')   return `[ENVIAR_FOTO_PRODUTO:Essa √© a Progressiva Vegetal Profissional üåø sem formol e com brilho de sal√£o ‚ú®]`;
  return null;
}

// Legenda da foto de abertura (sem link, como combinado)
function legendaFotoAbertura() {
  return pick([
    'Essa √© a Progressiva Vegetal Profissional üåø sem formol e com brilho de sal√£o ‚ú®',
    'Olha a Progressiva Vegetal Profissional üåø quer que eu te explique rapidinho como funciona?'
  ]);
}

// Gera comando especial para o transport converter em imagem real
// Formato: [ENVIAR_FOTO_PRODUTO:LEGENDA AQUI]
function comandoFotoAbertura() {
  const legenda = legendaFotoAbertura();
  return `[ENVIAR_FOTO_PRODUTO:${legenda}]`;
}

// ===== BOT =====
export const bot = {
  async handleMessage({ userId = 'unknown', text = '', context = {} }) {
    const mem = await getMemory(userId);
    const step = mem?.step || 'greet';
    const jaEnviouFotoAbertura = Boolean(mem?.welcomed);

    let reply = '';
    let newStep = step;

    try {
      // 0) Pol√≠tica de m√≠dia: se vier m√≠dia real (context.hasMedia) OU texto indicando m√≠dia
      if (context?.hasMedia || textIndicaMidia(text)) {
        reply = respostaMidia();
        // Mant√©m o step atual; apenas orienta a resumir por texto
        await setMemory(userId, {
          step,
          lastUserText: text,
          welcomed: jaEnviouFotoAbertura,
          updatedAt: Date.now()
        });
        return reply;
      }

      // Prioridade m√°xima: se o usu√°rio fez pergunta direta, respondemos direto
      const intent = detectDirectIntent(text);
      const direct = directAnswer(intent);
      if (direct) {
        // Foto na abertura (se ainda n√£o foi) + resposta direta
        let prefixoFoto = '';
        if (!jaEnviouFotoAbertura) prefixoFoto = comandoFotoAbertura() + '\n';
        const out = `${prefixoFoto}${direct}`.trim();

        await setMemory(userId, {
          step, lastUserText: text, welcomed: true, updatedAt: Date.now()
        });
        return out;
      }

      // 1) Fluxo principal por etapas
      if (step === 'greet') {
        reply = await greet({ text, context, prompts, productPrompt });
        newStep = 'qualify';
      } else if (step === 'qualify') {
        reply = await qualify({ text, context, prompts, productPrompt });
        // avan√ßa s√≥ se detectar inten√ß√£o m√≠nima (ajust√°vel conforme seu crit√©rio)
        newStep = /sim|quero|interessad|como funciona|tem entrega/i.test(text) ? 'offer' : 'qualify';
      } else if (step === 'offer') {
        reply = await offer({ text, context, prompts, productPrompt, price: PRICE_TARGET });
        newStep = 'close';
      } else {
        reply = await closeDeal({ text, context, prompts, productPrompt, price: PRICE_TARGET });
        newStep = 'close';
        reply = enforceSingleQuestion(reply);
      }

      // 2) Foto autom√°tica na abertura da conversa (uma vez por usu√°rio, por persist√™ncia)
      //    Enviamos SEMPRE quando for a primeira intera√ß√£o (mem.welcomed falsy).
      //    O transport (smartSend) converte [ENVIAR_FOTO_PRODUTO:...] em imagem real com legenda.
      let prefixoFoto = '';
      if (!jaEnviouFotoAbertura) {
        prefixoFoto = comandoFotoAbertura() + '\n';
      }

      // 3) Resposta final (se houver prefixo de foto, vai primeiro; depois o texto da etapa)
      reply = `${prefixoFoto}${reply}`.trim();

    } catch (err) {
      console.error('[BOT][ERR]', err);
      reply = 'Dei uma travadinha aqui. Quer que eu te passe o passo a passo rapidinho?';
    }

    // 4) Persist√™ncia de mem√≥ria (marca welcomed ap√≥s a primeira resposta)
    await setMemory(userId, {
      step: newStep,
      lastUserText: text,
      welcomed: true, // ap√≥s primeira resposta, consideramos foto enviada
      updatedAt: Date.now()
    });

    return reply;
  }
};
